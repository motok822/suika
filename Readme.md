# スイカゲーム

## ゲーム内容
20×20のボードの左上に1×1~4×4の大きさの正方形のブロックが現れる。

キーボードのdで右、aで左に動かすことができ、場所が決まったらsを押すと下まで落下する。また、ブロックから下方向に方向ガイドが出るのでそれを基準にして落下場所を選択できます。

その際に自分と同じ数字が書かれたブロックと上下左右のいづれかで接触していると合体して一つ数字が大きなブロックになる。元々あったブロックが落ちてきたブロックを吸収するイメージ。7が最大のブロックで、7が二つつながると消える。大きくなる方向は、他のブロックを押しのけずに大きくなることができる方向が近くにあるならその方向（元々あったブロックの左から優先的に探索され、元々あったブロックが接触しているエリアしか探索されない。）で、無理だったら左に押しのける。それも無理なら右に押しのける。それも無理なら合体しない。  

ブロックがたまり新しいブロックが上部に出現できなくなるとゲームオーバー。スコアは合体が発生するたびに増えていく。

##  遊び方
code.c linklist.c main.c push.c suika.h Makefileをダウンロードして、make runとコマンドを実行したのちに./suikaコマンドを実行すると遊べます。

## 大変だったこと
ブロックが合体して大きくなる際に、他のブロックを押しのけて大きくなるのを実装するのがめちゃくちゃ大変だった。結局ブロックが上下左右方向に接触しているブロックをリンクリストで管理して、グラフを構築し、dfsのようなことをした。左右どちらにも動けない場合に関しては合体しないということで実装を諦めてしまった。

案としてはブロックを円状にして中心からの斥力でブロックの配置を連続値で計算し、最後に離散化してボード上に表示するなどの方法を思いついたが、実装の手間から諦めた。


可変長配列を使うことのできる言語(C++とか)であればリンクリストのエラーに苦しめられることもなかったんだろうな...

## 工夫したこと
工夫したことは構造体の定義の仕方に尽きる。いろいろ考えたけど下のようにブロック(Point)をグラフのノードのようにして定義したことで合体の処理がうまくいったし、ボードをPoint *の2次元配列にすることで何も考えずにBoardにPoint *を代入していけばよかったので楽だった。
```c
typedef struct Point{
    int x;
    int y;
    fruit weight;
    int state;
    struct LinkList* above;
    struct LinkList* below;
    struct LinkList* right;
    struct LinkList* left;
}Point;
```
```c
typedef struct Board{
    Point*** field;
}Board;
```
